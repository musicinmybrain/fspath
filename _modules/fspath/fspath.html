
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>fspath.fspath &#8212; FSPath 20190323 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FSPath 20190323 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">fspath.fspath</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fspath.fspath</h1><div class="highlight"><pre>
<span></span># -*- coding: utf-8; mode: python -*-
u&quot;&quot;&quot;
semantic path names and much more
&quot;&quot;&quot;

# pylint: disable=invalid-name, bad-continuation

# ==============================================================================
# imports
# ==============================================================================

import sys
import io
import os
from os import path
import platform
import re
import shutil
import subprocess
from glob import iglob
from contextlib import closing
import zipfile
import tarfile

import six
from six.moves.urllib.request import urlopen # pylint: disable=E0401

from .progressbar import progressbar, humanizeBytes
from .helper import Options

# ==============================================================================
<div class="viewcode-block" id="FSPath"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath">[docs]</a>class FSPath(six.text_type):  # pylint: disable=too-many-public-methods
# ==============================================================================

    u&quot;&quot;&quot;
    A path name to a file or folder.

    Handling path names more comfortable, e.g.:

    * concatenate path names with the division operator ``/``
    * call functions like *mkdir* on path names
    * get properties like *EXISTS*

    .. code-block:: python

      &gt;&gt;&gt; from fspath import FSPath
      &gt;&gt;&gt; tmp = FSPath(&#39;~/tmp&#39;)
      &gt;&gt;&gt; tmp
      &#39;/home/user/tmp&#39;
      &gt;&gt;&gt; tmp.EXISTS
      False

    no additional import, no juggling with ``os.join(...)``

    simply slash ``/`` and ``foo.&lt;method&gt;`` calls

    .. code-block:: python

      &gt;&gt;&gt; [(tmp/x).makedirs() for x in (&#39;foo&#39;, &#39;bar&#39;)]
      True, True
      &gt;&gt;&gt; for n in tmp.listdir():
      ...     print(tmp / n)
      ...
      /home/user/tmp/foo
      /home/user/tmp/bar

    downloads &amp; archives

    .. code-block:: python

      &gt;&gt;&gt; arch = foo / &#39;fspath.zip&#39;
      &gt;&gt;&gt; url = &#39;https://github.com/return42/fspath/archive/master.zip&#39;

   ``download`` -- super easy download + segmentation + nice ticker

    .. code-block:: python

      &gt;&gt;&gt; arch.download(url, chunksize=1024, ticker=True)
      /home/user/tmp/foo/fspath.zip: [87.9 KB][===============    ]  83%

   ``FSPath.extract`` -- extract in one step, no matter ZIP or TAR

    .. code-block:: python

      &gt;&gt;&gt; arch.ISTAR, arch.ISZIP
      (False, True)
      &gt;&gt;&gt; arch.extract(foo)
      [&#39;fspath-master/&#39;, &#39;fspath-master/.gitignore&#39;
      , &#39;fspath-master/MAINFEST.in&#39;, &#39;fspath-master/Makefile&#39;
      , &#39;fspath-master/README.rst&#39;,  ... ]

    For more examples see our `slide-show &lt;../slides/index.html&gt;`_.

    &quot;&quot;&quot;

    OS = Options(
        sep       = os.sep     # https://docs.python.org/3/library/os.html#os.sep
        , curdir  = os.curdir  # https://docs.python.org/3/library/os.html#os.curdir
        , altsep  = os.altsep  # https://docs.python.org/3/library/os.html#os.altsep
        , extsep  = os.extsep  # https://docs.python.org/3/library/os.html#os.extsep
        , pathsep = os.pathsep # https://docs.python.org/3/library/os.html#os.pathsep
        , defpath = os.defpath # https://docs.python.org/3/library/os.html#os.defpath
        , linesep = os.linesep # https://docs.python.org/3/library/os.html#os.linesep
        , devnull = os.devnull # https://docs.python.org/3/library/os.html#os.devnull
    )

    def __new__(cls, pathname):
        u&quot;&quot;&quot;Constructor of a path name object.

        Regardless of how the encoding of the file system is, the ``pathname``
        is converted to unicode. The conversion of byte strings is based the
        default encodings.

        To issue &quot;File-system Encoding&quot; See also:

        * https://docs.python.org/3.5/howto/unicode.html#unicode-filenames
        &quot;&quot;&quot;
        pathname = path.normpath(path.expanduser(six.text_type(pathname)))
        return super(FSPath, cls).__new__(cls, pathname)

    @property
    def VALUE(self):
        u&quot;&quot;&quot;string of the path name&quot;&quot;&quot;
        return six.text_type(self)

    @property
    def EXISTS(self):
        u&quot;&quot;&quot;True if file/pathname exist&quot;&quot;&quot;
        return path.exists(self)

    @property
    def SIZE(self):
        u&quot;&quot;&quot;Size in bytes&quot;&quot;&quot;
        return path.getsize(self)

    @property
    def READABLE(self):
        u&quot;&quot;&quot;True if file/path is readable&quot;&quot;&quot;
        return os.access(self, os.R_OK)

    @property
    def WRITEABLE(self):
        u&quot;&quot;&quot;True if file/path is writeable&quot;&quot;&quot;
        return os.access(self, os.W_OK)

    @property
    def EXECUTABLE(self):
        u&quot;&quot;&quot;True if file is executable&quot;&quot;&quot;
        return os.access(self, os.X_OK)

    @property
    def ISDIR(self):
        u&quot;&quot;&quot;True if path is a folder&quot;&quot;&quot;
        return path.isdir(self)

    @property
    def ISFILE(self):
        u&quot;&quot;&quot;True if path is a file&quot;&quot;&quot;
        return path.isfile(self)

    @property
    def ISABSPATH(self):
        u&quot;&quot;&quot;True if path is absolute&quot;&quot;&quot;
        return path.isabs(self)

    @property
    def ISLINK(self):
        u&quot;&quot;&quot;True if path is a symbolic link&quot;&quot;&quot;
        return path.islink(self)

    @property
    def ISMOUNT(self):
        u&quot;&quot;&quot;True if path is a mountpoint&quot;&quot;&quot;
        return path.ismount(self)

    @property
    def MTIME(self):
        &quot;&quot;&quot;Return the last modification time, reported by os.stat().&quot;&quot;&quot;
        return os.stat(self).st_mtime

    @property
    def ATIME(self):
        &quot;&quot;&quot;Return the last access time, reported by os.stat().&quot;&quot;&quot;
        return os.stat(self).st_atime

    @property
    def CTIME(self):
        &quot;&quot;&quot;Return the metadata change time, reported by os.stat().&quot;&quot;&quot;
        return os.stat(self).st_ctime

    @property
    def ISZIP(self):
        u&quot;&quot;&quot;True if path is a ZIP file&quot;&quot;&quot;
        return zipfile.is_zipfile(self)

    @property
    def ISTAR(self):
        u&quot;&quot;&quot;True if path is a TAR archive file&quot;&quot;&quot;
        return tarfile.is_tarfile(self)

    @property
    def DIRNAME(self):
        u&quot;&quot;&quot;The path name of the folder, where the file is located

        E.g.: ``/path/to/folder/filename.ext`` --&gt; ``/path/to/folder``
        &quot;&quot;&quot;
        return self.__class__(path.dirname(self))

    @property
    def BASENAME(self):
        u&quot;&quot;&quot;The path name with suffix, but without the folder name.

        E.g.: ``/path/to/folder/filename.ext`` --&gt; ``filename.ext``
        &quot;&quot;&quot;
        return self.__class__(path.basename(self))

    @property
    def FILENAME(self):
        u&quot;&quot;&quot;The path name without folder and suffix.

        E.g.: ``/path/to/folder/filename.ext`` --&gt; ``filename``

        &quot;&quot;&quot;
        return self.__class__(path.splitext(path.basename(self))[0])

    @property
    def SUFFIX(self):
        u&quot;&quot;&quot;The filename suffix

        E.g.: ``/path/to/folder/filename.ext`` --&gt; ``.ext``

        &quot;&quot;&quot;
        return self.__class__(path.splitext(self)[1])

    @property
    def SKIPSUFFIX(self):
        u&quot;&quot;&quot;The complete file name without suffix.

        E.g.: ``/path/to/folder/filename.ext`` --&gt; ``/path/to/folder/filename``
        &quot;&quot;&quot;
        return self.__class__(path.splitext(self)[0])

    @property
    def ABSPATH(self):
        u&quot;&quot;&quot;The absolute pathname

        E.g: ``../to/../to/folder/filename.ext`` --&gt; ``/path/to/folder/filename.ext``

        &quot;&quot;&quot;
        return self.__class__(path.abspath(self))

    @property
    def REALPATH(self):
        u&quot;&quot;&quot;The real pathname without symbolic links.&quot;&quot;&quot;
        return self.__class__(path.realpath(self))

    @property
    def POSIXPATH(self):
        u&quot;&quot;&quot;The path name in *POSIX* notation.

        Helpfull if you are on MS-Windows and need the POSIX name.
        &quot;&quot;&quot;
        if os.sep == &quot;/&quot;:
            return six.text_type(self)
        else:
            p = six.text_type(self)
            if p[1] == &quot;:&quot;:
                p = &quot;/&quot; + p.replace(&quot;:&quot;, &quot;&quot;, 1)
            return p.replace(os.sep, &quot;/&quot;)

    @property
    def NTPATH(self):
        u&quot;&quot;&quot;The path name in the Windows (NT) notation.
        &quot;&quot;&quot;
        retVal = None
        if os.sep == &quot;\\&quot;:
            retVal = six.text_type(self)
        else:
            retVal = six.text_type(self).replace(os.sep, &quot;\\&quot;)
        return retVal

    @property
    def EXPANDVARS(self):
        u&quot;&quot;&quot;Path with environment variables expanded.&quot;&quot;&quot;
        return self.__class__(path.expandvars(self))

    @property
    def EXPANDUSER(self):
        u&quot;&quot;&quot;Path with an initial component of ~ or ~user replaced by that user&#39;s home.&quot;&quot;&quot;
        return self.__class__(path.expanduser(self))

<div class="viewcode-block" id="FSPath.getHOME"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.getHOME">[docs]</a>    @classmethod
    def getHOME(cls):
        u&quot;&quot;&quot;User&#39;s home folder.&quot;&quot;&quot;
        return cls(path.expanduser(&quot;~&quot;))</div>

<div class="viewcode-block" id="FSPath.getCWD"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.getCWD">[docs]</a>    @classmethod
    def getCWD(cls):
        u&quot;&quot;&quot;Current working directory.&quot;&quot;&quot;
        return cls(os.getcwd())</div>

<div class="viewcode-block" id="FSPath.chdir"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.chdir">[docs]</a>    def chdir(self):
        u&quot;&quot;&quot;change the current working directory to *self*.&quot;&quot;&quot;
        os.chdir(self)</div>

<div class="viewcode-block" id="FSPath.makedirs"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.makedirs">[docs]</a>    def makedirs(self, mode=0o775):
        u&quot;&quot;&quot;Recursive directory creation, default mode is 0o775 (octal).

        :param int mode: file permissons
        :return: created (True) already exists (True),
        :raises Exception: in case of errors (permissons, etc.)
        &quot;&quot;&quot;
        retVal = False
        if not self.ISDIR:
            os.makedirs(self, mode)
            retVal = True
        return retVal</div>

    def __div__(self, pathname):
        return self.__class__(self.VALUE + os.sep + six.text_type(pathname))
    __truediv__ = __div__

    def __rdiv__(self, pathname):
        return self.__class__(six.text_type(pathname) + os.sep + self.VALUE)

    def __add__(self, other):
        return self.__class__(self.VALUE + six.text_type(other))

    def __radd__(self, other):
        return self.__class__(six.text_type(other) + self.VALUE)

<div class="viewcode-block" id="FSPath.relpath"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.relpath">[docs]</a>    def relpath(self, start):
        u&quot;&quot;&quot;Return a relative version of a path&quot;&quot;&quot;
        return self.__class__(path.relpath(self, start))</div>

<div class="viewcode-block" id="FSPath.splitpath"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.splitpath">[docs]</a>    def splitpath(self):
        u&quot;&quot;&quot;Split a pathname.

        Return tuple (head, tail) where tail is everything after the final
        slash.  Either part may be empty.&quot;&quot;&quot;
        head, tail = path.split(self)
        return (self.__class__(head), self.__class__(tail))</div>

<div class="viewcode-block" id="FSPath.listdir"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.listdir">[docs]</a>    def listdir(self):
        u&quot;&quot;&quot;Return a iterator which yields the names of the files in the directory.&quot;&quot;&quot;
        for name in os.listdir(self):
            yield self.__class__(name)</div>

<div class="viewcode-block" id="FSPath.glob"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.glob">[docs]</a>    def glob(self, pattern, relpath=False):
        u&quot;&quot;&quot;Return an iterator which yields the paths matching a pathname pattern.

        The pattern may contain simple shell-style wildcards a la
        fnmatch. However, unlike fnmatch, filenames starting with a dot are
        special cases that are not matched by &#39;*&#39; and &#39;?&#39;  patterns.
        &quot;&quot;&quot;
        for name in  iglob(self / pattern):
            obj = self.__class__(name)
            if relpath is True:
                obj = obj.relpath(self)
            yield obj</div>

<div class="viewcode-block" id="FSPath.walk"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.walk">[docs]</a>    def walk(self, topdown=True, onerror=None, followlinks=False):
        u&quot;&quot;&quot;Directory tree generator.

        For each directory in the directory tree rooted at top (including top
        itself, but excluding &#39;.&#39; and &#39;..&#39;), yields a 3-tuple::

            folder, dirnames, filenames

        dirnames is a list of the names of the subdirectories in dirpath
        (excluding &#39;.&#39; and &#39;..&#39;).  filenames is a list of the names of the
        non-directory files in dirpath.

        Note that the names in the lists are just names, with no path components.
        To get a full path (which begins with top) to a file or directory in
        dirpath, do ``folder / name``.

        By default, os.walk does not follow symbolic links to subdirectories on
        systems that support them.  In order to get this functionality, set the
        optional argument &#39;followlinks&#39; to true.

        .. caution::

           If you pass a relative pathname for top, don&#39;t change the current
           working directory between resumptions of walk.  walk never changes
           the current directory, and assumes that the client doesn&#39;t either.

        For more details see ``os.walk``&quot;&quot;&quot;

        # argh those fu.. idiots from python impleted fspath in 3.4 which no
        # longer supports string-like objects (inheritance of str) in os.walk.
        # So we have to typecast str(self).

        for dirpath, dirnames, filenames in os.walk(str(self), topdown, onerror, followlinks):
            dirs = [self.__class__(x) for x in dirnames]

            yield (self.__class__(dirpath)
                   , dirs
                   , [self.__class__(x) for x in filenames])

            for name in list(dirnames):
                if name not in dirs:
                    dirnames.remove(name)</div>


<div class="viewcode-block" id="FSPath.reMatchFind"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.reMatchFind">[docs]</a>    def reMatchFind(self, name, use_files=True, use_dirs=True, followlinks=False, relpath=False):
        u&quot;&quot;&quot;Returns iterator which yields matching path names

        :param use_files:   iterator includes names of files
        :param use_dirs:    iterator includes names of folders
        :param followlinks: follow symbolic links

        To find all C and header files use::

            folder.reMatchFind(&quot;*\\.[ch]&quot;)

        To find the first C or header file use::

            next(myFolder.reMatchFind(&quot;*\\.[ch]&quot;), None)
        &quot;&quot;&quot;

        name_re = re.compile(name)
        for folder, dirnames, filenames in self.walk(followlinks=followlinks):
            if use_dirs:
                for d_name in [x for x in dirnames if name_re.match(x)]:
                    obj = folder / d_name
                    if relpath:
                        obj = obj.relpath(self)
                    yield obj
            if use_files:
                for f_name in [x for x in filenames if name_re.match(x)]:
                    obj = folder / f_name
                    if relpath:
                        obj = obj.relpath(self)
                    yield obj</div>

<div class="viewcode-block" id="FSPath.suffix"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.suffix">[docs]</a>    def suffix(self, new_suffix):
        u&quot;&quot;&quot;Return path name with ``new_suffix``&quot;&quot;&quot;
        return self.__class__(self.SKIPSUFFIX + new_suffix)</div>

<div class="viewcode-block" id="FSPath.copyfile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.copyfile">[docs]</a>    def copyfile(self, dest, preserve=False):
        u&quot;&quot;&quot;Copy the file src to the file or directory dest.

        :dest str: The destination may be a directory
        :preserve bool: copies permission bits
        &quot;&quot;&quot;
        if preserve:
            shutil.copy2(self, dest)
        else:
            shutil.copy(self, dest)</div>

<div class="viewcode-block" id="FSPath.copytree"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.copytree">[docs]</a>    def copytree(self, dest, symlinks=False, ignore=None):
        u&quot;&quot;&quot;Recursively copy the entire directory tree&quot;&quot;&quot;
        shutil.copytree(self, dest, symlinks, ignore)</div>

<div class="viewcode-block" id="FSPath.move"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.move">[docs]</a>    def move(self, dest):
        u&quot;&quot;&quot;Move path to another location (dest)&quot;&quot;&quot;
        shutil.move(self, dest)
        return self.__class__(dest)</div>

<div class="viewcode-block" id="FSPath.delete"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.delete">[docs]</a>    def delete(self):
        u&quot;&quot;&quot;remove file/folder&quot;&quot;&quot;
        if self.ISDIR:
            self.rmtree()
        else:
            self.rmfile()</div>

<div class="viewcode-block" id="FSPath.rmtree"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.rmtree">[docs]</a>    def rmtree(self, ignore_errors=False, onerror=None):
        u&quot;&quot;&quot;remove tree&quot;&quot;&quot;
        shutil.rmtree(self, ignore_errors, onerror)</div>

<div class="viewcode-block" id="FSPath.rmfile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.rmfile">[docs]</a>    def rmfile(self):
        u&quot;&quot;&quot;remove file&quot;&quot;&quot;
        os.remove(self)</div>

<div class="viewcode-block" id="FSPath.filesize"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.filesize">[docs]</a>    def filesize(self, precision=None):
        u&quot;&quot;&quot;Filesize in bytes or with precision&quot;&quot;&quot;
        size = path.getsize(self)
        if precision is not None:
            size = humanizeBytes(size, precision)
        return size</div>

<div class="viewcode-block" id="FSPath.openTextFile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.openTextFile">[docs]</a>    def openTextFile(self
                     , mode=&#39;rt&#39;, encoding=&#39;utf-8&#39;
                     , errors=&#39;strict&#39;, buffering=1
                     , newline=None):
        u&quot;&quot;&quot;Open file as text file.

        wraps `io.open &lt;https://docs.python.org/library/io.html#io.open&gt;`_:

        * except argument ``closefd`` (meaningless when using filenames)
        * ``encoding=&#39;utf-8&#39;`` is default
        * ``mode=&#39;rt&#39;`` is default
        * ``buffering=1`` is default (selects line buffering)
        &quot;&quot;&quot;
        return io.open(self
                       , mode=mode, encoding=encoding
                       , errors=errors, buffering=buffering
                       , newline=newline)</div>

<div class="viewcode-block" id="FSPath.openBinaryFile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.openBinaryFile">[docs]</a>    def openBinaryFile(self, mode=&#39;rb&#39;, errors=&#39;strict&#39;, buffering=None):
        u&quot;&quot;&quot;Open file as binary file.

        wraps `io.open &lt;https://docs.python.org/library/io.html#io.open&gt;`_:

        * except argument ``closefd`` (meaningless when using filenames)
        * except argument ``encoding`` (meaningless since *binary*)
        * except argument ``newline`` (meaningless since *binary*)
        * ``mode=&#39;rb&#39;`` is default
        &quot;&quot;&quot;
        return io.open(self, mode=mode, errors=errors, buffering=buffering)</div>

<div class="viewcode-block" id="FSPath.startFile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.startFile">[docs]</a>    def startFile(self):
        &quot;&quot;&quot;Start a file with its associated application.&quot;&quot;&quot;
        system  = platform.system()
        if system == &#39;Windows&#39;:
            os.startfile(self) # pylint: disable=no-member
            return
        cmd = &#39;xdg-open&#39;
        if system in (&#39;FreeBSD&#39;, &#39;Darwin&#39;):
            cmd = &#39;open&#39;

        from ._which import which
        cmd = which(cmd, findall=False)
        if cmd:
            os.system(cmd + &quot; &quot; + self)</div>

<div class="viewcode-block" id="FSPath.readFile"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.readFile">[docs]</a>    def readFile(self, encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;):
        u&quot;&quot;&quot;read entire file&quot;&quot;&quot;
        with self.openTextFile(encoding=encoding, errors=errors) as f:
            return f.read()</div>

<div class="viewcode-block" id="FSPath.extract"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.extract">[docs]</a>    def extract(self, folder=&quot;.&quot;, pwd=None, ticker=False, pipe=sys.stdout):
        u&quot;&quot;&quot;Extract TAR or ZIP archive to &#39;folder&#39;

        Uses ``extractall`` from :py:class:`tarfile.TarFile` and
        :py:class:`zipfile.Zipfile` to extract into ``folder``.

        :folder str: folder to extract into
        :pwd str: password for crypted (only ZIP)
        :return: members in an iterable form (list or just iterator)
        &quot;&quot;&quot;

        class ArchiveMember(object): # pylint: disable=missing-docstring, too-few-public-methods
            u&quot;&quot;&quot;wrapper for an archive member (tar or zip members)&quot;&quot;&quot;
            def __init__(self, member, archive):
                self.ISTAR       = isinstance(archive, tarfile.TarFile)
                self.ISZIP       = isinstance(archive, zipfile.ZipFile)
                self.archive     = archive
                if self.ISTAR:
                    self.member  = member
                    self.name    = FSPath(member.name)
                    self.size    = member.size
                elif self.ISZIP:
                    self.member  = self.archive.getinfo(member)
                    self.name    = FSPath(self.member.filename)
                    self.size    = self.member.file_size

            def extract(self, folder=&quot;&quot;, pwd=None):
                u&quot;&quot;&quot;wrapped extract member function&quot;&quot;&quot;
                if self.ISTAR:
                    self.archive.extract(self.member, folder or &quot;&quot;)
                elif self.ISZIP:
                    self.archive.extract(self.member, folder or None, pwd)
                else:
                    raise tarfile.ExtractError(&quot;%s archive type is unknown&quot; % self.member)

        if self.ISTAR:
            arc = tarfile.open(self, &#39;r:*&#39;)
            am  = list(arc.getmembers())
            mx  = len(am)
        elif self.ISZIP:
            arc = zipfile.ZipFile(self)
            am  = list(arc.namelist())
            mx  = len(am)
        else:
            raise tarfile.ExtractError(&quot;%s archive type is unknown&quot; % self)

        if ticker and not isinstance(ticker, bool):
            tick_func = ticker
        else:
            def tick_func(member, counter, max_count):
                u&quot;&quot;&quot;extract&#39;s default ticker&quot;&quot;&quot;
                n = member.name.BASENAME
                progressbar(counter, max_count
                            , prompt = &quot;extract: %-20s&quot; % (n if len(n) &lt; 20 else n + &quot;..&quot;)
                            , pipe   = pipe)

        folder = self.__class__(folder)
        if not folder.EXISTS:
            folder.makedirs()

        members = []
        for c, m in enumerate(am, start=1):
            m = ArchiveMember(m, arc)
            members.append(m)
            if ticker:
                tick_func(m, c, mx)
            m.extract(folder, pwd)

        if ticker and isinstance(ticker, bool):
            pipe.write(&#39;\n&#39;)

        return members</div>


<div class="viewcode-block" id="FSPath.Popen"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.Popen">[docs]</a>    def Popen(self, *args, **kwargs):  # pylint: disable=invalid-name
        u&quot;&quot;&quot;Get a ``subprocess.Popen`` object (``proc``).

        The path name of the self-object is the programm to call. The program
        arguments are given py ``*args`` and the ``*kwargs`` are passed to the
        ``subprocess.Popen`` constructor. The ``universal_newlines=True`` is
        true by default.

        see https://docs.python.org/3/library/subprocess.html#popen-constructor

        .. code-block:: python

           from fspath import FSPath
           proc = FSPath(&quot;arp&quot;).Popen(&quot;-a&quot;,)
           stdout, stderr = proc.communicate()
           retVal = proc.returncode
           print(&quot;stdout: %s&quot; % stdout)
           print(&quot;stderr: %s&quot; % stderr)
           print(&quot;exit code = %d&quot; % retVal)

        &quot;&quot;&quot;

        defaults = {
            &#39;stdout&#39;               : subprocess.PIPE
            , &#39;stderr&#39;             : subprocess.PIPE
            , &#39;stdin&#39;              : subprocess.PIPE
            , &#39;universal_newlines&#39; : True
            }
        defaults.update(kwargs)
        return subprocess.Popen([self,] + list(args), **defaults)</div>

<div class="viewcode-block" id="FSPath.download"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.FSPath.download">[docs]</a>    def download(self, url, chunksize=1048576, ticker=False, pipe=sys.stdout):
        u&quot;&quot;&quot;Download URL into file

        The default chunksize is 1048576 Bytes, with ticker=True an progress-bar
        is prompted.

        E.g. to download FSPath&#39;s README.rst with a progressbar on stdout::

            url = &quot;https://raw.githubusercontent.com/return42/fspath/master/README.rst&quot;

            readme = FSPath(&quot;README.rst&quot;)
            readme.download(url, ticker=True)
        &quot;&quot;&quot;

        if ticker and not isinstance(ticker, bool):
            tick_func = ticker
        else:
            def tick_func(fname, down_bytes, max_bytes):
                u&quot;&quot;&quot;download&#39;s default ticker&quot;&quot;&quot;
                progressbar(down_bytes, max_bytes
                            , prompt = &quot;download: %s[%s]&quot; % (fname.BASENAME, humanizeBytes(max_bytes, 1))
                            , pipe   = pipe)

        with closing(urlopen(url)) as d:
            with open(self, &quot;wb&quot;) as f:
                # pylint: disable=no-member
                max_bytes  = int(d.headers.get(&quot;Content-Length&quot;, 0))
                down_bytes = 0
                if chunksize is None:
                    chunksize = max_bytes // 100
                while 1:
                    x = d.read(chunksize)
                    if not bool(len(x)):
                        break
                    f.write(x)
                    down_bytes += len(x)
                    if ticker:
                        tick_func(self, down_bytes, max_bytes)
                if ticker:
                    pipe.write(&#39;\n&#39;)</div></div>


# ==============================================================================
<div class="viewcode-block" id="callEXE"><a class="viewcode-back" href="../../fspath-api/fspath.fspath.html#fspath.fspath.callEXE">[docs]</a>def callEXE(cmd, *args, **kwargs):
# ==============================================================================

    u&quot;&quot;&quot;
    Synchronous command call ``cmd`` with arguments ``*args`` .

    The ``*kwargs`` are passed to the ``subprocess.Popen`` constructor. The
    return value is a three-digit tuple ``(stdout, stderr, rc)``.

    .. code-block:: python

       from fspath import callEXE
       out, err, rc = callEXE(&quot;arp&quot;, &quot;-a&quot;)

       print(&quot;stdout: %s&quot; % out)
       print(&quot;stderr: %s&quot; % err)
       print(&quot;exit code = %d&quot; % rc)
    &quot;&quot;&quot;
    from ._which import which
    exe = which(cmd, findall=False)
    if exe is None:
        raise IOError(&#39;command &quot;%s&quot; not availble!&#39; % cmd)
    proc = exe.Popen(*args, **kwargs)
    stdout, stderr = proc.communicate()
    retVal = proc.returncode
    return (stdout, stderr, retVal)</div>


# ==============================================================================
class DevNull(object): # pylint: disable=too-few-public-methods
# ==============================================================================

    &quot;&quot;&quot;A dev/null file descriptor.&quot;&quot;&quot;
    def write(self, *args, **kwargs):
        u&quot;&quot;&quot;writer which writes nothing&quot;&quot;&quot;
        pass

DevNull = DevNull() # pylint: disable=invalid-name
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/darmarIT_logo_128.png" alt="Logo"/>
            </a></p>
  
<h3>Navigation</h3>
<ul>
  <li><a href="../../index.html">Overview</a>
    <ul>
      <li><a href="../index.html">Module code</a>
        
          
          </ul>
      </li>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div id="ethical-ad-placement"></div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023 Markus Heiser.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  <script src="../../_static/version_warning_offset.js"></script>

  </body>
</html>